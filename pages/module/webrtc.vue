<template>
    <!-- 新建文件的模板 -->
    <div class="page">
        <contents>
            <codes>webrtc</codes> (Web Real-Time Communications)
            是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC
            包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。
        </contents>

        <div class="page__area">
            <video
                id="localVideo"
                class="page__area_video"
                autoplay
                playsinline
                muted
            ></video>

            <video
                id="userVideo"
                class="page__area_video"
                autoplay
                playsinline
                muted
            ></video>
        </div>
        <div class="page__list" id="imgarea">
            <!-- <img id="testimg" class="page__list_item" src="" alt="" /> -->
            <!-- <div
                v-for="(item, index) in imgList.length"
                :key="index"
                class="page__list_item"
            >
                <img :src="item" alt="" />
            </div> -->
        </div>

        <div class="page__operate">
            <el-button class="page__operate_button" type="primary" @click="join"
                >加入</el-button
            >
            <el-button
                class="page__operate_button"
                type="primary"
                @click="leave"
                >离开</el-button
            >
            <el-button
                class="page__operate_button"
                type="primary"
                @click="takePhoto"
                >拍照</el-button
            >
            <el-button
                class="page__operate_button"
                type="primary"
                @click="sharScreen"
                >分享屏幕</el-button
            >

            <el-select
                class="page__operate_button"
                v-model="recordType"
                placeholder="请选择录制方式"
            >
                <el-option label="一次性录制" value="all"> </el-option>
                <el-option label="间隔录制" value="interval"> </el-option>
            </el-select>
        </div>
        <div class="page__operate">
            <el-button
                class="page__operate_button"
                type="primary"
                @click="startRecord(1)"
                >录制用户视频</el-button
            >
            <el-button
                class="page__operate_button"
                type="primary"
                @click="startRecord(2)"
                >录制屏幕视频</el-button
            >

            <el-button
                class="page__operate_button"
                type="primary"
                @click="stopRecord"
                >结束录制</el-button
            >
            <el-button
                class="page__operate_button"
                type="primary"
                @click="downloadVideo"
                >下载录制视频</el-button
            >
        </div>
    </div>
</template>

<script>
export default {
    head() {
        return {
            title: "webrtc",
            meta: "",
            description: "练习webrtc",
            script: []
        };
    },
    data() {
        return {
            imgList: [],
            canvas: {
                width: "300px",
                height: "300px"
            },
            showImg: false,
            // 滤镜信息
            filterList: [
                "blur(5px)", // 模糊
                "brightness(0.5)", // 亮度
                "contrast(200%)", // 对比度
                "grayscale(100%)", // 灰度
                "hue-rotate(90deg)", // 色相旋转
                "invert(100%)", // 反色
                "opacity(90%)", // 透明度
                "saturate(200%)", // 饱和度
                "saturate(20%)", // 饱和度
                "sepia(100%)", // 褐色
                "drop-shadow(4px 4px 8px blue)" // 阴影
            ],

            // 支持的数据类型
            supported: [],

            // 媒体流数据 用于录制共享屏幕
            localStream: "",

            mediaRecorder: null,

            // 录制的数据列表
            blobList: [],

            // 一次性下载 all , 间隔下载 interval
            recordType: "interval",

            // 录制数据
            blobData: "",

            // 设置时间轮询获取
            timer: null,

            // 时间间隔
            timecell: 5000
        };
    },
    mounted() {
        // this.getDevices();
        this.getSupportMimeTypes();
    },
    methods: {
        join() {
            this.getUserMedia();
        },

        leave() {
            document.querySelector("#userVideo").srcObject = null;
        },

        // 获取屏幕共享的媒体流
        async sharScreen() {
            try {
                let localStream = await navigator.mediaDevices.getDisplayMedia({
                    audio: true,
                    video: true
                });

                // 播放本地视频流
                this.playStream(localStream);
            } catch {
                console.log("Error: 获取屏幕媒体流信息失败!");
            }
        },

        playStream(stream) {
            console.log("视屏流信息", stream);
            const video = document.querySelector("#localVideo");
            // srcObject 属性设定或返回一个对象，这个对象提供了一个与HTMLMediaElement关联的媒体源，这个对象通常是 MediaStream ，
            // 但根据规范可以是 MediaSource， Blob 或者 File。
            video.srcObject = stream;
        },

        // 获取摄像头信息
        async getUserMedia() {
            try {
                // constraints参数中具体支持哪些配置项
                // console.log(
                //     "🚀🚀🚀 / SupportedConstraints",
                //     navigator.mediaDevices.getSupportedConstraints()
                // );

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: true
                });

                const video = document.querySelector("#userVideo");

                // srcObject 属性设定或返回一个对象，这个对象提供了一个与HTMLMediaElement关联的媒体源，这个对象通常是 MediaStream ，
                // 但根据规范可以是 MediaSource， Blob 或者 File。
                video.srcObject = stream;
            } catch {
                console.log(
                    "Error: 获取摄像头/音频流信息失败!, 请检查是否授予页面摄像头/音频使用权限"
                );
            }
        },

        // 拍照
        takePhoto() {
            // HTMLVideoElement 接口提供了用于操作视频对象的特殊属性和方法。它同时还继承了HTMLMediaElement 和 HTMLElement 的属性与方法。
            const videoEL = document.querySelector("#localVideo");

            if (!videoEL.srcObject) {
                console.log("Warning 请先分享视频");
                return;
            }

            console.log("视频元素", videoEL.srcObject);
            const canvas = document.createElement("canvas");
            // HTMLVideoElement 支持获取 videoWidth 和 videoHeight 属性
            canvas.width = videoEL.videoWidth;
            canvas.height = videoEL.videoHeight;
            var ctx = canvas.getContext("2d");
            // 绘制图片
            ctx.drawImage(videoEL, 0, 0, canvas.width, canvas.height);

            // 直接推入图片循环列表 src 会被识别为数字 不会展示图片
            this.imgList.push(canvas.toDataURL("image/png"));

            // 改到第二种方法创建元素推入
            const img = document.createElement("img");
            img.className = "page__list_item";
            img.src = canvas.toDataURL("image/png");
            document.querySelector("#imgarea").appendChild(img);
        },

        // 拍摄的时候我们也可以切换摄像头，这里我们通过调用 navigator.mediaDevices.enumerateDevices 方法，获取到所有的设备
        async getDevices() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            // kind 为 videoinput 的为摄像头 每个设备都有一个 deviceId，
            console.log("🚀🚀🚀 / devices", devices);

            // 可以通过这个 id 来切换设备 获取媒体流
            // const stream = await navigator.mediaDevices.getUserMedia({
            //     audio: false,
            //     video: {
            //         // 指定设备Id
            //         deviceId: { exact: deviceId }
            //     }
            // });
        },

        // 媒体记录
        getSupportMimeTypes() {
            const media = "video";
            // 常用的视频格式
            const types = [
                "webm",
                "mp4",
                "ogg",
                "mov",
                "avi",
                "wmv",
                "flv",
                "mkv",
                "ts",
                "x-matroska"
            ];

            // 常用的视屏编码
            const codecs = [
                "vp9",
                "vp9.0",
                "vp8",
                "vp8.0",
                "avc1",
                "av1",
                "h265",
                "h264"
            ];

            // 返回布尔值来表示是否支持
            const isSupportted = MediaRecorder.isTypeSupported;

            // 支持的结果
            const supported = [];

            // 遍历类型，排列组合
            types.forEach(type => {
                const mimeType = `${media}/${type}`;
                codecs.forEach(codec => {
                    [
                        `${mimeType};codecs=${codec}`,
                        `${mimeType};codecs=${codec.toUpperCase()}`
                    ].forEach(variation => {
                        if (isSupportted(variation)) supported.push(variation);
                    });
                });

                if (isSupportted(mimeType)) supported.push(mimeType);
            });

            this.supported = supported;
            console.log("支持的视屏类型", supported);
        },

        // 录制媒体流
        startRecord(type) {
            let stream = "";
            if (type == 1) {
                stream = document.querySelector("#userVideo").srcObject || null;
            } else {
                stream =
                    document.querySelector("#localVideo").srcObject || null;
            }

            if (!stream) {
                console.log(`未获取到${type == 1 ? "用户" : "屏幕"}相关流数据`);
                return;
            }

            const kps = 1024;
            const Mbps = kps * kps;
            const options = {
                audioBitsPerSecond: 128000,
                videoBitsPerSecond: 2500000,
                mimeType: "video/webm;codecs=vp8,opus"
            };
            console.log("媒体流", stream);
            /**
             *  流数据可以是来自于使用 navigator.mediaDevices.getUserMedia() 创建的流或者来自于
             *   <audio>, <video> 以及 <canvas> DOM 元素。
             */
            this.mediaRecorder = new MediaRecorder(stream, options);

            if (this.recordType == "all") {
                // 开始录制 state 变为 recording
                this.mediaRecorder.start();
                this.setRecorder();
            } else {
                // 间隔获取 需要传入timeslice
                this.mediaRecorder.start(this.timecell);
                this.setInterval();
            }

            console.log("mediaRecorder实例", this.mediaRecorder);
        },

        // 间隔获取录制数据
        setInterval() {
            // 清空
            this.blobList = [];
            this.mediaRecorder.ondataavailable = e => {
                // 🌸重点是这个地方，我们不要把获取到的 e.data.type设置成 blob 的 type，而是直接改成 mp4
                // 暂停
                this.mediaRecorder.pause();
                let tempData = new Blob([e.data], { type: "video/webm" });
                console.log("slice数据", tempData);

                this.blobList.push(tempData);
                // 恢复录制
                this.mediaRecorder.resume();
            };
        },

        // 一次性获取录制数据
        setRecorder() {
            /**
             *  媒体流结束时，所有尚未传递到ondataavailable处理程序的媒体数据都将在单个Blob中传递。
             *  当调用MediaRecorder.stop() (en-US)时，自记录开始或dataavailable事件最后一次发生
             *  以来已捕获的所有媒体数据都将传递到Blob}中；此后，捕获结束。也可以使用 requestData，
             *  调用MediaRecorder.requestData() (en-US) dataavailable时，将传递自记录开始或事件
             *  最后一次发生以来捕获的所有媒体数据；然后Blob创建一个新文件，并将媒体捕获继续到该 blob 中。
             */
            this.mediaRecorder.ondataavailable = e => {
                // 将录制的数据合并成一个 Blob 对象
                // const blob = new Blob([e.data], { type: e.data.type })
                console.log("data", e.data);

                // 🌸重点是这个地方，我们不要把获取到的 e.data.type设置成 blob 的 type，而是直接改成 mp4
                this.blobData = new Blob([e.data], { type: "video/webm" });
            };
        },

        // 停止录制
        stopRecord() {
            // 录制的状态：inactive（未开始或停止）,recording(正在录制)，paused（暂停）
            if (this.mediaRecorder?.state !== "inactive") {
                // let requestData = this.mediaRecorder.requestData();
                // console.log("requestData", requestData);
                this.mediaRecorder.stop();
            }
        },

        // 下载
        downloadVideo() {
            if (this.recordType == "all") {
                this.downloadBlob();
            } else {
                this.intervalDownload();
            }
        },

        // for 循环下载
        intervalDownload() {
            console.log("blobList", this.blobList);
            let data = "";
            for (let i in this.blobList) {
                setTimeout(() => {
                    // 将 Blob 对象转换成一个 URL 地址
                    let url = URL.createObjectURL(this.blobList[i]);
                    console.log("临时路由", url);
                    let videoItem = document.createElement("video");
                    videoItem.className = "page__area_video";
                    videoItem.src = url;
                    document
                        .querySelector(".page__area")
                        .appendChild(videoItem);
                    let a = document.createElement("a");
                    // 设置 a 标签的 href 属性为刚刚生成的 URL 地址
                    a.href = url;
                    // 设置 a 标签的 download 属性为文件名
                    a.download = `list${i}.${
                        this.blobList[i].type.split("/")[1]
                    }`;
                    // 模拟点击 a 标签
                    a.click();
                    // 释放 URL 地址
                    // URL.revokeObjectURL(url);
                }, i * 1000);
            }
        },

        // 一次性 下载 Blob
        downloadBlob() {
            if (!this.blobData?.type) {
                console.log("未录制视频");
                return;
            }

            // 将 Blob 对象转换成一个 URL 地址
            const url = URL.createObjectURL(this.blobData);
            const a = document.createElement("a");
            // 设置 a 标签的 href 属性为刚刚生成的 URL 地址
            a.href = url;
            // 设置 a 标签的 download 属性为文件名
            a.download = `${new Date().getTime()}.${
                this.blobData.type.split("/")[1]
            }`;
            // 模拟点击 a 标签
            a.click();
            // 释放 URL 地址
            URL.revokeObjectURL(url);
        }
    },

    beforeDestroy() {}
};
</script>

<style lang="less">
@import "~assets/less/index.less";
.page {
    &__area {
        width: 100%;
        min-height: 300px;
        margin: 0 0 20px 0;
        background: @colorebecec;
        .flex(stretch, flex-start, wrap, row);
        &_video {
            height: 300px;
            flex: 1;
        }
    }

    &__list {
        width: 100%;
        margin: 0 0 20px 0;
        background: @colorebecec;
        .flex(stretch, flex-start, row, wrap);

        &_item {
            margin: 0 10px 10px 0;
            width: 200px;
            height: 200px;
        }

        &_item img {
            max-width: 200px;
            max-height: 200px;
            object-fit: contain;
        }
    }

    &__operate {
        &_button {
            margin: 0 10px 10px 0;
        }
    }
}
</style>
